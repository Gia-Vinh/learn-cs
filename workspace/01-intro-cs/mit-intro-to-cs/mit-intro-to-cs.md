

2024-05-12

[link to course](https://learning.edx.org/course/course-v1:MITx+6.00.1x+2T2018/home)

> **MOTIVATION**
>
> Goal: 
> - Moving from electrical engineering, try to give my career a bit more cs foundation.
> 
> Expected positive outcomes
> -   I'll start to have systematic knowledge in my career, enhance my chances of finding new places to work or simply get promoted for current.  
> 
> Expected obstacles and plan to overcome
> - Time: 
>     - as a married adult with full time job, the work life balance is already challenging. So I'll have to cut some of my leisure time for the learning. 
>     - To overcome, i'll have to cut down the allocated time for this course to the point it is still sustainable.
> - Morale: 
>     - demotivated during the course.
>     - To overcome, i'll take a break for a few days with actual plan when to come back

# Week 1: Python basics
## Introduction to python

Try to think of a problem in a computational manner.

ENGAGE WITH COMPUTATIONAL MODE OF THINKING

what does a computer do?
    * perfoms calculations really fast
    * remember results
 
TYPES OF KNOWLEDGE

computer knows what you tell them

Declarative knowledge is a statement of fact 
 
    > i.e. There is candy taped to the underside of one chair

Imperative knowledge is a receipe or "how-to"
 
    > i.e. a how to recipe to cook an egg.

=> this is a what we need to focus on in this course

**Computer are machines**. Let's look into how to capture a recipe in mechanical process:


* Fixed program computer. i.e Calculator, [Alan Turing's bombe](https://en.wikipedia.org/wiki/Bombe)
* stored program computer. i.e.: machines stores and execute instructions
-> advantage is that they can do a different task when a different program is loaded in to the memory. This is what we gonna focus on

<!-- Basic Machine Architecture:

                    Memory

|    |                    |         |

Control Unit        <->  Arthimetic logic unit

Program counter             Do primitive ops

                |           |   

                Input   output
                 -->

Stored program counter
- sequence of instructions stored inside computer
    - built from predefined set of primitive instructions
        1. arithmetic and logic
        2. simple tests
        3. moving data
- special program (interpreter) executes each instruction in order
    - use tests to change flow of control through sequence
    - stop when done

Basic primitives
- Turing showed you can compute anything using 6 primitives
- those are:
    1. move left
    2. move right
    3. scan
    4. read
    5. write
    6. do nothing
- modern programming have more convenitent set of primitives
- can abstract methods to create new primitives
- anything computable in one language is computable in any other programming language

Creating recipes:
- a programming language provides a set of primitives **operations**
- **Expressions** are complex but leagal combinations of primitives in a programming language
- expressions are computations have **values** and meanings in a programming language

Aspects of languages
- primitive constructs
    - english:words
    - programming language: numbers, strings, simple operators


